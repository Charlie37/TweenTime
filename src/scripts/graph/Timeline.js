// Generated by CoffeeScript 1.6.2
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(function(require) {
    var $, Errors, Header, Items, Keys, Properties, Signals, TimeIndicator, Timeline, Utils, d3, extend;

    $ = require('jquery');
    d3 = require('d3');
    Signals = require('Signal');
    Utils = require('cs!core/Utils');
    Header = require('cs!graph/Header');
    TimeIndicator = require('cs!graph/TimeIndicator');
    Items = require('cs!graph/Items');
    Properties = require('cs!graph/Properties');
    Keys = require('cs!graph/Keys');
    Errors = require('cs!graph/Errors');
    extend = function(object, properties) {
      var key, val;

      for (key in properties) {
        val = properties[key];
        object[key] = val;
      }
      return object;
    };
    return Timeline = (function() {
      function Timeline(tweenTime, selectionManager) {
        var height, margin, self, width,
          _this = this;

        this.tweenTime = tweenTime;
        this.selectionManager = selectionManager;
        this.render = __bind(this.render, this);
        this.isDirty = true;
        this.onSelect = new Signals.Signal();
        this.timer = this.tweenTime.timer;
        this.currentTime = this.timer.time;
        this.initialDomain = [0, this.timer.totalDuration - 220 * 1000];
        margin = {
          top: 6,
          right: 20,
          bottom: 0,
          left: 190
        };
        this.margin = margin;
        width = window.innerWidth - margin.left - margin.right;
        height = 270 - margin.top - margin.bottom - 40;
        this.lineHeight = 20;
        this.label_position_x = -170;
        this.x = d3.time.scale().range([0, width]);
        this.x.domain(this.initialDomain);
        this.xAxis = d3.svg.axis().scale(this.x).orient("top").tickSize(-height, 0).tickFormat(Utils.formatMinutes);
        this.svg = d3.select('.timeline__main').append("svg").attr("width", width + margin.left + margin.right).attr("height", 600);
        this.svgContainer = this.svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        this.svgContainerTime = this.svg.append("g").attr("transform", "translate(" + margin.left + ",0)");
        this.linesContainer = this.svg.append("g").attr("transform", "translate(" + margin.left + "," + (margin.top + 10) + ")");
        this.header = new Header(this.timer, this.initialDomain, this.tweenTime, width);
        this.timeIndicator = new TimeIndicator(this, this.svgContainerTime);
        self = this;
        console.log(this.linesContainer);
        this.linesContainer.on("mousedown", function() {
          var p;

          p = d3.mouse(this);
          return self.linesContainer.append('rect').attr({
            rx: 6,
            ry: 6,
            "class": 'selection',
            x: p[0],
            y: p[1],
            width: 0,
            height: 0
          });
        }).on("mousemove", function() {
          var containerBounding, d, move, p, s;

          s = self.linesContainer.select('.selection');
          if (s.empty()) {
            return;
          }
          p = d3.mouse(this);
          d = {
            x: parseInt(s.attr('x'), 10),
            y: parseInt(s.attr('y'), 10),
            width: parseInt(s.attr('width'), 10),
            height: parseInt(s.attr('height'), 10)
          };
          move = {
            x: p[0] - d.x,
            y: p[1] - d.y
          };
          if (move.x < 1 || move.x * 2 < d.width) {
            d.x = p[0];
            d.width -= move.x;
          } else {
            d.width = move.x;
          }
          if (move.y < 1 || move.y * 2 < d.height) {
            d.y = p[1];
            d.height -= move.y;
          } else {
            d.height = move.y;
          }
          s.attr(d);
          console.log(".......");
          d.timeStart = self.x.invert(d.x).getTime() / 1000;
          d.timeEnd = self.x.invert(d.x + d.width).getTime() / 1000;
          console.log(d);
          containerBounding = self.linesContainer[0][0].getBoundingClientRect();
          d3.selectAll('.key__shape--selected').classed('key__shape--selected', false);
          return d3.selectAll('.key').each(function(state_data, i) {
            var itemBounding, y;

            itemBounding = d3.select(this)[0][0].getBoundingClientRect();
            y = itemBounding.top - containerBounding.top;
            if (state_data.time >= d.timeStart && state_data.time <= d.timeEnd) {
              console.log(y + " / " + d.y);
              if (y >= d.y && y <= d.y + d.height) {
                console.log("ok");
                return console.log(state_data);
              }
            }
          });
        }).on("mouseup", function() {
          return self.linesContainer.selectAll('.selection').remove();
        });
        this.items = new Items(this, this.linesContainer);
        this.items.onUpdate.add(function() {
          return _this.isDirty = true;
        });
        this.items.onSelect.add(function(d) {
          return _this.onSelect.dispatch(d);
        });
        this.properties = new Properties(this);
        this.properties.onKeyAdded.add(function() {
          return _this.isDirty = true;
        });
        this.errors = new Errors(this);
        this.keys = new Keys(this);
        this.keys.onKeyUpdated.add(function() {
          return _this.isDirty = true;
        });
        this.xAxisGrid = d3.svg.axis().scale(this.x).ticks(100).tickSize(-this.items.dy, 0).tickFormat("").orient("top");
        this.xGrid = this.svgContainer.append('g').attr('class', 'x axis grid').attr("transform", "translate(0," + margin.top + ")").call(this.xAxisGrid);
        this.xAxisElement = this.svgContainer.append("g").attr("class", "x axis").attr("transform", "translate(0," + margin.top + ")").call(this.xAxis);
        this.header.onBrush.add(function(extent) {
          _this.x.domain(extent);
          _this.xGrid.call(_this.xAxisGrid);
          _this.xAxisElement.call(_this.xAxis);
          return _this.isDirty = true;
        });
        window.requestAnimationFrame(this.render);
        window.onresize = function() {
          var INNER_WIDTH;

          INNER_WIDTH = window.innerWidth;
          width = INNER_WIDTH - margin.left - margin.right;
          _this.svg.attr("width", width + margin.left + margin.right);
          _this.svg.selectAll('.timeline__right-mask').attr('width', INNER_WIDTH);
          _this.x.range([0, width]);
          _this.xGrid.call(_this.xAxisGrid);
          _this.xAxisElement.call(_this.xAxis);
          return _this.header.resize(INNER_WIDTH);
        };
      }

      Timeline.prototype.render = function(time, time_changed) {
        var bar, height, properties;

        if (this.isDirty || time_changed) {
          this.header.render();
          this.timeIndicator.render();
        }
        if (this.isDirty) {
          bar = this.items.render();
          properties = this.properties.render(bar);
          this.errors.render(properties);
          this.keys.render(properties);
          this.isDirty = false;
          height = Math.max(this.items.dy + 30, 230);
          this.xAxis.tickSize(-height, 0);
          this.xAxisGrid.tickSize(-height, 0);
          this.xGrid.call(this.xAxisGrid);
          this.xAxisElement.call(this.xAxis);
          return this.svg.attr("height", height);
        }
      };

      return Timeline;

    })();
  });

}).call(this);
